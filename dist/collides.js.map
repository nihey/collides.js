{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap cddd349407352520bbad","webpack:///./lib/index.js","webpack:///./lib/utils.js"],"names":[],"mappings":"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","file":"collides.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"collides\"] = factory();\n\telse\n\t\troot[\"collides\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cddd349407352520bbad\n **/","let Utils = require('utils');\n\nmodule.exports = function(a, b) {\n  a = Utils.parse(a);\n  b = Utils.parse(b);\n  return Utils.intersect(a, b) && Utils.intersect(b, a);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/index.js\n **/","let Utils = {\n  /* Nomalize a vector\n   *\n   * Normalized vectors are the ones with length = 1, so that the statement:\n   *\n   * |vector| = Math.sqrt(vector.x * vector.x + vector.y * vector.y) = 1\n   *\n   * is true.\n   *\n   * This can be achieved by dividing the vector's magnitude/length (|vector|)\n   * by each of its coordinates:\n   *\n   * vector = vector / |vector|\n   */\n  normalize: function(vector) {\n    var length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n    return {\n      x: vector.x / length,\n      y: vector.y / length,\n    };\n  },\n\n  /* Executes a dot product between vectors 'a' and 'b' */\n  dot: function(a, b) {\n    return a.x * b.x + a.y * b.y;\n  },\n\n  /* Returns a perpendicular vector to the input */\n  perpendicular: function(vector) {\n    return {\n      x: -vector.y,\n      y: vector.x,\n    };\n  },\n\n  /* Project a polygon onto an axis\n   *\n   * +---------+ -> Polygon\n   * |         |\n   * |         |\n   * +---------+\n   *\n   * |*********|---------------------- -> Axis\n   *\n   * |---------| -> projection\n   *\n   * @returns return the maximum and minimal interval resulting from the\n   *          projection\n   * @param polygon {Object[]} The polygon that will be projected\n   * @param axis {Object} The axis that will receive the projection\n   */\n  project: function(polygon, axis) {\n    let [max, min] = [-Infinity, Infinity];\n\n    // Do not use forEach loop to increase execution speed\n    for (let i = 0; i < polygon.length; ++i) {\n      let dot = this.dot(polygon[i], axis);\n      max = Math.max(dot, max);\n      min = Math.min(dot, min);\n    }\n\n    return {\n      max: max,\n      min: min,\n    };\n  },\n\n  /* Returns the distance between 'a' and 'b' intervals\n   *\n   * |*********|---------|********************|---------- -> Positive distance\n   *\n   * ^         ^         ^                    ^\n   * | a.min   | a.max   | b.min              | b.max\n   *\n   * |*****************|**************|***************|-- -> Negative distance\n   *\n   * ^                 ^              ^               ^\n   * | a.min           | b.min        | a.max         | b.max\n   *\n   * This is used to test whether two given intervals intersect or not.\n   */\n  distance: function(a, b) {\n    if (a.min < b.min) {\n      return b.min - a.max;\n    }\n    return a.min - b.max;\n  },\n\n  /* Test polygon intersection according to the SAT (Separating Axis Theorem)\n   *\n   * For further reading about SAT, refer to:\n   * http://www.metanetsoftware.com/technique/tutorialA.html\n   *\n   * @param a {Object[]} The main polygon we'll be testing, by extracting its\n   *                     edges\n   * @param b {Object[]} The polygon that will be projected onto a\n   *                     perpendicular edges\n   */\n  intersect: function(a, b) {\n    for (let i = 0; i < a.length; ++i) {\n      // Get the edge that we'll be testing intersection against\n      let next = (i + 1) % a.length;\n      // edge AB is defined by B - A\n      let edge = {\n        x: a[next].x - a[i].x,\n        y: a[next].y - a[i].y,\n      };\n\n      // Get the perpendicular axis relative to the edge that we'll be testing\n      var axis = this.perpendicular(edge);\n\n      // Get the projection intervals\n      var intervalA = this.project(a, axis);\n      var intervalB = this.project(b, axis);\n\n      // If the distance between the two intervals is greater than zero, the\n      // two intervals do not intersect - therefore no collision is ocurring\n      if (this.distance(intervalA, intervalB) > 0) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n\n  /* Returns which type of polygon the given object is\n   *\n   * We currently accept this types of polygons:\n   *\n   * 'rectangle' - {defined by having a width parameter}\n   * 'polygon' - {is an array}\n   */\n  type: function(object) {\n    if (object.width) {\n      return 'rectangle';\n    }\n    return 'polygon';\n  },\n\n  /* Returns the array of vertexes for a polygon (when possible) */\n  types: {\n    rectangle: function(rectangle) {\n      return [\n        {x: rectangle.x, y: rectangle.y},\n        {x: rectangle.x + rectangle.width, y: rectangle.y},\n        {x: rectangle.x + rectangle.width, y: rectangle.y - rectangle.height},\n        {x: rectangle.x, y: rectangle.y - rectangle.height},\n      ];\n    },\n  },\n\n  /* Converts a described polygon into an array of vertexes (when possible) */\n  parse: function(object) {\n    if (Array.isArray(object)) {\n      return object;\n    }\n    return this.types[this.type(object)](object);\n  },\n};\n\nexport default Utils;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/utils.js\n **/"],"sourceRoot":""}